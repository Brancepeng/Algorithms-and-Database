1.为什么要有对象?
程序到底是什么
我们都知道一个说法：数据结构+算法=程序；但有没有思考过，为什么一定是“数据结构”？
为什么不说“数据+算法=程序”
因为数据太底层了
数据,仅仅是字符/字符串,整型,浮点型等'基本元素',我们可以用这些数据写一个公式,但却无法用它写一个复杂的算法.
哪怕简单的排序算法,二分查找算法.他们都有一个基本的要求-数据的组织形式.
比如，你要搞一个链表，能在上面实现“二分查找”吗
二分查找的基本需求是数据有序、且可以通过下标之类方式“随机访问”——链表只能从前往后访问，所以无法在上面实现二分查找。
因此,'算法'必须和数据结构结合,没有数据结构是谈不上算法的.

“数据结构+算法=程序”就够用了吗？
很显然,不够用.
这是因为,在数据结构和算法这个层面,我们只能看到按照一定规律结合的一些数据、这些数据按一定规律密密麻麻的排布着、等待我们去处理。

这就好像你到了工地，翻开花名册一看，50万人。

你要算万人事故率和工资,那肯定够了.但你要说让这十个人去挖坑那十个人垒墙、张三请假了李四来顶班王五家里有事他凿了21.7%的石头要另外安排人继续凿下去……

只靠花名册，这显然是不够用的

怎么办呢?

你得把人按职业分开,石匠、木匠、铁匠、泥瓦匠……

还得把人按等级分开，比如初级石匠、高级石匠、工匠大师……

还得按任务分开，比如挖墓道的、凿石棺的……

还得按职务分,比如这五人一伍,去干这份工,那十人'一什',去做那件事.然后百人归一个“百夫长”管、千人共有一个上司叫“千户”……

只靠一本花名册,当然是做不了的.

当然了.我们可以把一伍和一什当做一个数据结构,然后给他们写算法.

没错,这样迭代着用起来,仍然可以说“数据结构+算法=程序”就足够了……

问题是,50万人,10万个伍,每个伍都有自己的任务...你的算法得有多少个?如何正确的把合适的算法关联给正确的伍?

怎么办呢?

面向对象.

面向对象,说白了,就是把一个铁匠,一个石匠,一个专业队伍(伍)看做一个'对象'.然后把他们的'劳动'这个算法和每个对象绑定.

换句话说，它提供了一种基础设施，允许我们把“算法”和“相对应的对象”绑定；之后，我们就不再需要具体的去指挥一个对象，而是调用对象的“方法”，它就自动执行对应的算法了。

比如，你看见一个工人在旁边偷懒，不需要先去查他职业、搞明白他应该去干什么、怎么干，然后才能指挥他--而是只要大喊一声“去干活”，于是调用了 worker.work()接口，他就回去工作了。

什么工作呢？他自己知道——石匠就去凿石头，铁匠去打铁，诸如此类。你不需要多管。

类似的，一个伍，你让他们挖西侧墓道，那么你并不需要知道他们需要什么工具，伍长会负责这一切；伍长也不需要知道每一锹土怎么挖、怎么倒，他只需要指定一个地方，挖！挖完土倒这里！

好了，五十万人就这样井然有序的开工了。


面向对象的好处是什么

秩序井然

意思是代码组织的井井有条，不至于让石匠去打铁、铁匠去砍树；而是把“实体数据”和“相关操作”直接绑定起来了。

于是，你需要操作一个按钮，想要知道它支持哪些操作,就不需要从列表到树控件挨个看一遍、从名字相似的两万个函数中挑出入口参数是btn的200个、逐一分析它们的作用、然后才发现自己需要的功能在Window里面……

不仅如此.

比如，你实现了一个石匠类。那么你肯定不希望他正在为石狮子雕眼睛时，另一个人突然对着石狮子踹一脚。

类似的，你现在的“雕眼睛算法”写的很傻，所以你希望申请一下，下个版本改成更好的——那么，你肯定不希望有人能够“先让你雕一半眼睛、再突然翻个面继续雕于是搞出了一个很对称的眼睛”：一旦他这样做了，下个版本你就没办法改变“雕眼睛算法”了，不然非出大事故不可。

因此，你可以通过编程语言，直接表达如下约定：

1.请且仅请通过我的make_eye()接口雕眼睛.
2.石狮子的位置是我内部的变量,所以我用单下划线开头——python约定，这种变量是不允许外人使用的，只有我可以用。

这就避免了其他人错误的使用石匠类，方便了团队配合。

BTW，事实上，这套东西在10多年前就已经成了程序员们的“黑话”，可以极大幅度的提高团队配合效率。比如，c++里面的、非virtual析构函数就表示“不要继承我”，纯虚函数则表示“必须改写我”，等等。

这个东西，用术语说就是所谓的“封装性”。

接口统一

接口统一其实前面已经讲过了：上层指挥者/高层模块可以无视被调用者的具体区别，统一使用同样的信号指挥它。

在面向对象相关书籍里面，经常把这个叫做“多态性”，而且花费大量篇幅大讲特讲……

怎么说呢……如何实现“多态”，这的确不是很好懂；但我们程序员完全不关心什么多态。我们只关心“统一的接口”。

比如说，我们希望，通过网络传输数据，是打开一个socket文件然后fread/fwrite；使用USB驱动器也是打开文件然后fread/fwrite……你看，统一用fread/fwrite，节省我们的精力、降低我们的负担，这是很重要的。但具体为什么使用U盘和网络传输一样都可以fread/fwrite，我们需要关心吗？

组合灵活

前面提到过，一个“伍”可以由铁匠、石匠、木匠等等五个人组成；这些人的职业是不需要限制的。

换句话说，我们可以根据实际需要、任意组合出一个精悍的五人小队——或者十人小队

比如说，我们需要在程序里设置一个按钮，它是什么呢？

它首先是一个“窗口”，这个窗口会锚定在另一个窗口内部；它在鼠标悬停时（mouse over）会显示一张图片、或者叠加一个发光效果；而在鼠标按下时显示另一张图片，展示凹陷状态；鼠标移开后，显示第三张图片，展示弹起状态。

当鼠标点击它之后，它会调用on_click()这个接口里面填写的内容.
类似的，我们把窗口显示的东西替换成一个空白的圈圈、一个实心的圈圈；还可以把它们放进同一组里，然后通过逻辑使得只有一个起效或者全部可以起效.这就是redio控件和check控件。

你看，看似千变万化，其实都是同一个“窗口”对象以及附加的一些逻辑罢了。

这个东西，过去我们走过一段很长的弯路。那就是把它抽象为“继承”：按钮从窗口继承，按钮是一个窗口，但又额外多了一些功能……

这个抽象带来了很多不必要的复杂化，尤其是造成了继承类和父类的严重耦合；对C++，还有“棱形继承”这样一个极其讨厌、晦涩而又致命的问题。

因此，很早就有人提出了“优先使用组合而不是继承”这样的准则；编程语言们则纷纷开始支持“接口”——接口继承等于说“我支持该接口支持的所有操作”，不再关注“从父类拿到了什么”。

换句话说，你可以组合石匠、铁匠、木匠为一“伍”；然后你指着石头说“工作”，伍长就会把调用转发给石匠——这样同样可以支持“多态””，但却绕开了菱形继承等问题。

如何使用面向对象?

一句话,面向对象是为了方便我们程序员写程序.

很明显可以看出，上面提到的好处都是需要程序员主动去拿的，不存在“用了面向对象就有以上好处”的可能。

更简单的判定标准是：如果你能把程序写的更简单、更抗“需求变更”，那么无论你用了什么语言、什么模式，你就总是对的；但如果你用了面向对象、程序却变得更复杂、更害怕改动了，那你显然搞错了。

——还是那句话，c一样可以面向对象，而有些Java写的垃圾程序甚至连“结构化”都谈不上。

